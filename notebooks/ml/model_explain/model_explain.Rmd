---
title: "On Model Explainability"
subtitle: "From LIME, SHAP, to Explainable Boosting"
author:
- name: Kyle Chung
  affiliation:
date: "`r format(Sys.time(), '%d %b %Y')` Last Updated (09 Dec 2019 First Uploaded)"
output:
  html_notebook:
    highlight: tango
    number_sections: yes
    theme: paper
    toc: yes
    toc_depth: 4
    toc_float: yes
    includes:
      in_header: /tmp/meta_header.html
  code_download: true
bibliography: model_explain.bib
nocite: |
  @reticulate
  @maas-EtAl:2011:ACL-HLT2011
  @scikit-learn
  @tensorflow2015-whitepaper
abstract: |
  Model explainability has gained more and more attention recently among machine learning practitioners. Especially with the popularization of deep learning frameworks, which further promotes the use of increasingly complicated models to improve accuracy. In the reality, however, model with the highest accuracy may not be the one that can be deployed. Trust is one important factor affecting the adoption of complicated models. In this notebook we give a brief introduction to several popular methods on model explainability. And we focus more on the hands-on which demonstrates how we can actually explain a model, under a variety of model families.
---
<!-- Embed lime javascript library for explanation visualization.
  The source file, if not found, is programmatically generated within the notebook chunks.
-->
<script src="lime.js"></script>

<!-- Embed plotly javascript library.
  This is the backend for interpretML visualization.
-->
<script src="../../../site_libs/utils/plotly-1.51.1.min.js"></script>

```{r meta, include=FALSE}
meta_header_file <- file("/tmp/meta_header.html")

# Add open graph meta.
meta <- c(
  '<meta name="author" content="Kyle Chung">',
  '<meta property="og:title" content="On Model Explainability: From Shap, Lime, to Interpretable Boosting">',
  '<meta property="og:type" content="article">',
  '<meta property="og:url" content="https://everdark.github.io/k9/notebooks/ml/model_explain/model_explain.nb.html">',
  '<meta property="og:image" content="https://everdark.github.io/k9/assets/androidify.jpg">',
  '<meta property="og:description" content="A data science notebook about machine learning model explainability.">'
)
contents <- meta

# Add Github corner.
github_corner_svg <- "../../../assets/github_corner.html"
github_corner_conf <- list(github_link="https://github.com/everdark/k9/tree/master/notebooks/ml/model_explain")
contents <- c(contents, stringr::str_interp(readLines(github_corner_svg), github_corner_conf))
writeLines(contents, meta_header_file)

close(meta_header_file)
```

```{r setup, include=FALSE}
library(reticulate)
r <- try(use_python(Sys.getenv("PYTHON_PATH"), required=TRUE), silent=TRUE)
if ( is(r, "try-error") ) {
  r <- try(use_virtualenv(Sys.getenv("PYTHON_PATH"), required=TRUE), silent=TRUE)
  if ( is(r, "try-error") ) use_condaenv(Sys.getenv("PYTHON_PATH"), required=TRUE)
}

# Utility to post-process html output.
library(xml2)

# For some plots.
library(ggplot2)

write_lime_js <- function(infile) {
  # lime html output contains a huge js string,
  # to reduce notebook file size we only want to declare the js once.
  outfile <- "lime.js"
  doc <- as_list(read_html(infile))
  js_str <- doc$html$head$script[[1]]
  # Use h5 for text example header to avoid being included in rmd toc.
  js_str <- gsub("h3", "h5", js_str)
  writeLines(js_str, outfile, useBytes=TRUE)
}

parse_lime_html_output <- function(infile, exclude_js=TRUE) {
  outfile <- tempfile()
  doc <- read_html(infile)
  if ( exclude_js ) xml_remove(xml_child(doc))
  write_html(doc, outfile)
  outfile
}
```

---

This notebook is written with [`reticulate`](https://github.com/rstudio/reticulate),
a package that allows inter-operation between R and Python.

---

# Motivation

Why do we need to explain a machine learning model?
The benefit of an explanable model against a black-box model is for the model to be *trusted*.
Trust can be important in many real applications where the successful deployment of a machine learning model requires the trust from end users.
Sometimes trust plays a even bigger role than model accuracy.

Other than trust,
model explainability (or interpretability, interchangeably used hereafter) may also guide us in the correct direction to further improve the model.
^[Some people will further differentiate explainability from interpretability,
by characterizing interpretability as knowing how without knowing why,
and explainability as not only knowing how but also knowing why.
In this notebook for simplicity we don't take such approach.]

In general,
linear model is more interpretable than non-linear model.
But the former also suffers from lower accuracy.
More advanced and hence complicated model usually has worse interpretability.

One should not confuse model explainability with the actual causality.
Being able to explain a model doesn't mean that we can identify any ground-truth causal relation behind the model.
Model explainability is for and only for the model,
but not for the facts we'd like to model.
Nevertheless,
understand how we can reason the model definitely will help us better model the actual pattern behind the scence.

In this notebook we will walk through 3 popular approaches of model prediction explanation,
each of them comes with a dedicated Python package:

1. [`shap`](https://github.com/slundberg/shap)
2. [`lime`](https://github.com/marcotcr/lime)
3. [`interpret`](https://github.com/interpretml/interpret)

# Explanation Models

An explanation model $g(x\prime)$ is an *interpretable approximation* of the original model $f(x)$.
Its sole purpose is to give extra explainability the original model fails to provide,
due to its own complexity.

The general idea is to use a simplified input $x\prime$ such that $x = h_x(x\prime)$,
where $h_x(\cdot)$ is a mapping function for any given raw input $x$.
Then the interpretable approximation can be written as:

$$
g(x\prime) \approx f(h_x(x\prime)).
$$

The *additive feature attribution methods* specify the explanation model of the following form:

$$
g(x\prime) = \phi_0 + \sum_{i = 1}^m \phi_i x_i\prime,
$$

where $m$ is total number of simplified features,
$x\prime \in \{0, 1\}$ simply an indicator.^[In many such methods, the simplified input is the indicator of feature presence. One example: Shapley regression values.]
Apparently,
the choice of an additive model is for (linear) intrepretability.
The simplified features are an *interpretable representation* of the original model features.

As we will see additivity is the key to explainability.
All the approaches we will discuss in this notebook follow this philosophy.

# LIME

One very popular such above additive model is LIME (@ribeiro2016should).
LIME stands for **Local Interpretable Model-Agnostic Explanations.**
As its full name suggests,
LIME can be applied to *any* machine learning model.
LIME achieves prediction-level interpretability by approxmiating the original model with an explanation model locally around that prediction.

From their original paper:

> By “explaining a prediction”,
we mean presenting textual or visual artifacts that provide qualitative understanding of the relationship between the instance’s components (e.g. words in text, patches in an image) and the model’s prediction.

Feature space in the original model will be in general different from that of the explanation model.
An explanation model will use interpretable representation of the original feature as their training input.
Different data type will have their different interpretable representation.

## Binarized Interpretable Feature Space

LIME proposes an explanation model $g(x\prime)$ with a domain $\{0, 1\}$.
That is, it acts on absence or presence of the interpretable features $x\prime$.
The choice is, obviously, for better interpretability.

**Language Data**

For text classification problems with human language as source input,
the most straightforward interpretable representation will be *a binary indicator vector of bag of words.*
So the explanation model will try to reason which word or token is driving the prediction in what direction.
And this is true no matter the form of the original model feature.
May it be a word count matrix,
a term frequency-inverse document frequency (TF-IDF) matrix,
or numerical embeddings.

**Image Data**

For image tasks,
the interpretable representation is *a joint set of contiguous superpixels that divide the original image into pieces.*
A superpixel is a group of pixels with similar characteristics.
So in plain words, just like we segment sentence into tokens,
we simply segment image into multiple small pieces and again,
use a binary vector to indicate the absence or presence of each piece for latter perturbation purpose.

**Numerical Data**

TBC.

## Local Sampling (Perturbation)

In order to estimate the explanation model given a prediction for a target example,
features transformed into a interpretable space are then perturbed to generate similar examples around that target example.
This is referred to as sampling for local exploration.

Given an example $x\prime$ to be explained,
its non-zero interpretable features (remember the space has a domain of $\{0, 1\}$) are uniformly sampled to generate its local similar example $z\prime$.
So $z\prime$ will always have a subset (or at most equal set) of non-zero features that $x\prime$ has.

Take text data for illustration.
If a particular example has the following tokens in the interpretable space:

```
A B C H I J
```

Then a possible local sample can be something like:

```
A C H J
```

(Imagine those alphabets are actual words present in the raw text of the example.)

By default in the paper 5,000 samples are generated for each single explanation.
A hyperparameter $K$ (default at 10) is used to cap how many non-zero interpretable features we'd like to estimate in the subsequent model learning phase,
to not only keep the model solving tractable but also manageable for human interpretation.

## Learning Task of the Explanation Model

Now each of the perturbed example will be first *transformed back* to their original feature space,
then feed into the original model to get the predicted label.
That is,
from $z\prime$ we need to get $f(z)$ where $f$ is the original model and $z$ the original feature representation.
These labels serve exactly as the labels to train the local explanation model,
where all random perturbations $z$ are weigthed by $\pi_x(z)$,
a proximity function $\pi_x(z)$ can be defined to measure how close $z$ is to $x$,
in the original space.

In the original paper the proximity function is set to be an exponential kernel:

$$
\pi_x(z) = \exp \bigg( \frac{-D(x, z)^2}{\sigma^2} \bigg),
$$

where $D(x, z)$ is cosine distance for text and L2 distance for image,
$\sigma$ is a hyperparameter default at 25 in `lime`.

The learner is a simple linear model:

$$
g(x\prime) = W \cdot x\prime.
$$

We learn the explanation model weights $W$ by minimizing the sum of proximity-weighted squared losses for all perturbed local samples:

$$
Loss = \sum_{z, z\prime} \pi_x(z) \cdot \big(f(z) - g(z\prime)\big)^2.
$$

The actual learning algorithm proposed by LIME in the original paper is a [LASSO](https://en.wikipedia.org/wiki/Lasso_(statistics)).
But in the actual implementation of the `lime` package,
[Ridge regression](https://en.wikipedia.org/wiki/Tikhonov_regularization) is used instead as the default learner.
Despite this,
the top $K$ features for the learner are still chosen by a LASSO path.

Another discrepancy between the original paper and the actual implementation is the notion of proximity function $\pi_x(z)$.
In the actual implementation proximity is calculated in the interpretable space rather than in the original space.
So essentially we should have denoted the function as $\pi_{x\prime}(z\prime)$.
Indeed,
in the package source code the proximity function is defined as:
^[In the R package [`iml`](https://github.com/christophM/iml) the default distance function for LIME is Gower's distance,
which is designed to handle distance in data with mixed types.]

$$
\pi_{x\prime}(z\prime) = \sqrt{ \exp \bigg( \frac{-(D(x\prime, z\prime) \times 100)^2}{\sigma^2} \bigg)}.
$$

As one may realize now that the original model can be a total blackbox.
We only use its predictions as labels to learn the explanation model.
Be aware that here $f(z)$ returns the predicted *probability* as label so the explanation model is a regressor not a classifier.

## Limitations

**Linearity**

Notice that the local explanation model is a linear model,
the explanation hence is subject to linearity.
If we have any evidence suggesting heavy non-linearity around a prediction,
the output of such explanation model won't be faithful.

**No Explanation for a NULL Effect**

And for the local sampling,
notice that we only subsample from the presence of features on the target example.
So the explanation is on the presence or absence of the anything actually present in the target example.
A feature that is originally not present in the example can never be part of the explanation.
This could potentially miss an important null effect of a feature.

Take the same example above:

```
A B C H I J
```

It could be the case that,
instead of the presence of the 6 features,
the missingness of feature `Z` is the most important driving force for the machine learning model to make the prediction.
However due to the local sampling scheme,
the importance of (the null of) `Z` can never be estimated by the explanation model.

## Hands-on Explanation Demo

### On Text Classifiers

We use [Large Movie Review Dataset](https://ai.stanford.edu/~amaas/data/sentiment/) to do a binary sentiment classification exercise.
We will use machine learning libraries such as `scikit-learn` and `tensorflow` to quickly build a varieity of (rather complicated and hard to interpret) models and use `lime` to experiment explanation modeling.

```{python import_some}
import sys
print(sys.version)

import os
import logging
logging.getLogger("tensorflow").setLevel(logging.ERROR)
import warnings
warnings.simplefilter(action="ignore", category=UserWarning)
warnings.simplefilter(action="ignore", category=FutureWarning)

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

import tensorflow as tf
print(tf.__version__)
if tf.test.is_gpu_available():
  print(tf.test.gpu_device_name())

import sklearn
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.pipeline import make_pipeline
from sklearn.metrics import classification_report, roc_auc_score
from sklearn.model_selection import train_test_split
import joblib

print(sklearn.__version__)
```

```{python mkdir}
# Create model dir to cache all models trained in the notebook.
model_dir = "models"
if not os.path.exists(model_dir):
    os.makedirs(model_dir)

# Directory to cache dataset.
home = os.path.expanduser("~")
cache_dir = os.path.join(home, ".keras")
```

First,
we prepare the movie review dataset.^[Keras also comes with the dataset preprocessed as integer sequences (`from tf.keras.datasets import imdb`).]

```{python maybe_download_imdb, results="hide"}
import tensorflow_datasets as tfds

# Load the data as tf.data.Dataset.
imdb = tfds.load(name="imdb_reviews", as_supervised=True,
                 data_dir=os.path.join(home, "tensorflow_datasets"))
```

The dataset is a perfectly balanced dataset with 50,000 examples,
half for positive and half for negative sentiment.

```{python prepare_imdb}
# Extract all texts as list since we want to use libraries other than tensorflow as well.
# And since this is a small dataset, we don't care about memory usage.
# We skip the use of a dataset iterator.
imdb_reviews_train = []
imdb_reviews_test = []
imdb_y_train = []
imdb_y_test = []
for x, y in imdb["train"].batch(128):
  imdb_reviews_train.extend(x.numpy())
  imdb_y_train.extend(y.numpy())
for x, y in imdb["test"].batch(128):
  imdb_reviews_test.extend(x.numpy())
  imdb_y_test.extend(y.numpy())

# TF works on bytes, but some other packages may only work on decoded string.
imdb_reviews_train = [b.decode("utf8") for b in imdb_reviews_train]
imdb_reviews_test = [b.decode("utf8") for b in imdb_reviews_test]
imdb_y_train = np.array(imdb_y_train)
imdb_y_test = np.array(imdb_y_test)

# Take one review.
print(imdb_reviews_train[87])

print(imdb_y_train[87])  # Label. 0 as negative and 1 as positive.
```

We use the data prepared by `tensorflow-datasets` here just to save some time.
For those who want to process the data in its very original format (where one review is in one `.txt` file),
the files can be downloaded by this piece of code:

```python
imdb_remote_path = "https://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz"
imdb_fname = os.path.basename(imdb_remote_path)
imdb_local_path = os.path.join(cache_dir, "datasets", imdb_fname)

if not os.path.exists(imdb_local_path):
  _ = tf.keras.utils.get_file(fname=imdb_fname, origin=imdb_remote_path,
                              extract=True, cache_dir=cache_dir)
```

#### Explain Random Forest {-}

Let's build a random forest with TF-IDF as our feature space.
We will use the popular `scikit-learn` library for implementation.
^[It will be much faster if we choose `xgboost`'s or `lightgbm`'s implementation of random forest.
However, to demonstrate compatibility of `lime` with `scikit-learn` we purposely choose the slower implementation here.]

```{python tfidf}
# We drop words that are too frequent or too rare in the training dataset.
imdb_vectorizer = TfidfVectorizer(lowercase=True, min_df=10, max_df=.9)
imdb_X_train = imdb_vectorizer.fit_transform(imdb_reviews_train)
imdb_X_test = imdb_vectorizer.transform(imdb_reviews_test)
print(len(imdb_vectorizer.vocabulary_))  # Without OOV token.
```

```{python imdb_rf}
imdb_rf_model_file = os.path.join(model_dir, "text_rf.joblib")

# Save/reload the model to save notebook rendering time.
if os.path.exists(imdb_rf_model_file):
  imdb_rf = joblib.load(imdb_rf_model_file)
else:
  imdb_rf = RandomForestClassifier(n_estimators=300, random_state=64, n_jobs=-2)
  _ = imdb_rf.fit(imdb_X_train, imdb_y_train)
  _ = joblib.dump(imdb_rf, imdb_rf_model_file)

imdb_rf_pred = imdb_rf.predict(imdb_X_test)
imdb_rf_yhat = imdb_rf.predict_proba(imdb_X_test)[:,1]

print(classification_report(imdb_y_test, imdb_rf_pred))
print(roc_auc_score(imdb_y_test, imdb_rf_yhat))
```

As a baseline without extensive tuning (we didn't tune anything indeed!),
random forest seems to perform fairly well on this dataset.

As part of the algorithm's design we are able to derive a global view of feature importance.
This is based on how much each feature can reduce the impurity during all tree splittings.
For example,
we can plot the top 20 features:

```{python imdb_rf_feat_imp}
sorted_vocab = sorted(imdb_vectorizer.vocabulary_.items(), key=lambda kv: kv[1])
sorted_vocab = [w for w, i in sorted_vocab]

imdb_rf_feat_imp = pd.Series(imdb_rf.feature_importances_, index=sorted_vocab).sort_values()
ax = imdb_rf_feat_imp.tail(20).plot(kind="barh")
plt.show()
```

As one can see,
common adjectives describing good or bad things generally have larger impact in the model,
which is totally expected.
But we also see influential words such as `just` and `minutes` which are quite neutral and contain no useful information on their own.
They may be *jointly* important in the model since a tree model allows interaction between variables.
But we won't be able to go deeper beyond the unconditional view we derived as a global feature ranking.

Interpretation of the impurity-based ranking must be very careful.
For example,
related features will theoretically have similar impact but only one of it will gain higher score (and suppress the other) in the ranking.
Which one stands out is totally random due to the way tree splitting is performed during training.

In general it is NOT recommended to use impurity or loss-based feature ranking to *interpret* a tree ensemble model.
Such ranking information is still useful to understand different aspects of the model,
and can be used to subset feature to counter over-fitting issue, if any.
But it won't help really explain the model at the prediction-level: *Why is my model making such prediction?*
And this is exactly why we need a explanation model in the first place.

Now move on to model explanation with LIME.
We pick up one true positive and one false positive case made by our random forest model to see how the explanation model will explain each case.

```{python lime_imdb_rf}
from lime.lime_text import LimeTextExplainer

# We need a pipeline since LimeTextExplainer.explain_instance expects raw text input.
imdb_rf_pipe = make_pipeline(imdb_vectorizer, imdb_rf)
imdb_rf_explainer = LimeTextExplainer(class_names=["Negative", "Positive"], random_state=64)

imdb_rf_tp_idx = np.where(np.logical_and(imdb_rf_pred == 1, imdb_y_test == 1))[0]
imdb_rf_fp_idx = np.where(np.logical_and(imdb_rf_pred == 1, imdb_y_test == 0))[0]

# We take one true positive and one false positive example to demo explanation.
imdb_rf_tp_exp = imdb_rf_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_tp_idx[0]], imdb_rf_pipe.predict_proba, num_features=6)
imdb_rf_fp_exp = imdb_rf_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_fp_idx[0]], imdb_rf_pipe.predict_proba, num_features=6)
# For ipynb, one can simply call imdb_tp_exp.show_in_notebook(text=True) to embed the html output.

imdb_rf_tp_exp.save_to_file("/tmp/explain_text_rf_tp.html")
imdb_rf_fp_exp.save_to_file("/tmp/explain_text_rf_fp.html")
```

##### A True Positive Prediction Explained {-}

```{r, echo=FALSE}
if ( !file.exists("lime.js") ) {
  write_lime_js("/tmp/explain_text_rf_tp.html")
}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_rf_tp.html"))
```

<br>

Our RF model doesn't seem to be very confident on this particular positive example indeed.
There is no dominant single word can drive the prediction in the correct direction.
The contributing words are also mostly neutral on their own.
We can confirm that the result of this prediction will be very sensitive and not robust.
Admittedly this review does show some mixtures of positive and negative views.

##### A False Positive Prediction Explained {-}

Now let's look at a false positive example,
where our RF model wrongly labeled as a positive review.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_rf_fp.html"))
```

<br>

In this example a single positive word `great` (wrongly) dominate the prediction toward a positive sentiment.
And we realize the model didn't response well to some negative signals,
especially for the word `bore`.

If we examine more cases we may have more clues on how the model mis-behaves,
and we can come up with a strategy accordingly to improve it.
For now we'll stop here and try experimenting with other learning algorithms hereafer.

##### Build LIME from Scratch {-}

Let's use the text data example above to build a LIME model from scratch to better understand every detail of the technique.

```{python linme_from_scratch}
from scipy.sparse import csr_matrix
from sklearn.linear_model import Ridge, lars_path
from sklearn.metrics.pairwise import cosine_distances

N = 1000  # Number of local samples.
K = 10  # Number of features to used.
i = imdb_rf_tp_idx[0]  # The target example.
x = imdb_X_test[i]
local_samples_x = csr_matrix(np.ones([N, 1])) * x  # Container for perturbation.
present_tok_id = x.nonzero()[1]  # Present features.

# Generate random design matrix for the explanation model.
# This is under the interpretable (binary) space.
local_samples_z = (np.random.uniform(size=(N, len(present_tok_id))) > .5).astype(int)

# Predict local samples by the original model.
remove_ind = pd.DataFrame(zip(*np.where(local_samples_z == 0)), columns=["rid", "pos"])
for r in range(1, N):
  # We keep the first sample as the original target example.
  df = remove_ind[remove_ind.rid == r]
  if not df.empty:
    tok_ids_to_remove = present_tok_id[df.pos]
    local_samples_x[r,tok_ids_to_remove] = 0
local_samples_x.eliminate_zeros()
local_samples_y = imdb_rf.predict_proba(local_samples_x)[:,1]

# Calculate proximity weights under the interpretable space.
def pi_x(z):
  kernel_width = 25
  dist = cosine_distances(z[0].reshape(1, -1), z).ravel()
  return np.sqrt(np.exp(-((dist * 100) ** 2) / kernel_width ** 2))

weights = pi_x(local_samples_z)

# Subset top K features with LAR path.
weighted_z = ((local_samples_z - np.average(local_samples_z, axis=0, weights=weights))
  * np.sqrt(weights[:, np.newaxis]))
weighted_y = ((local_samples_y - np.average(local_samples_y, weights=weights))
  * np.sqrt(weights))
_, _, coefs = lars_path(weighted_z, weighted_y, method="lasso")

nonzero_coefs = range(weighted_z.shape[1])
for i in range(len(coefs.T) - 1, 0, -1):
    nonzero_coefs = coefs.T[i].nonzero()[0]
    if len(nonzero_coefs) <= 10:
        break

# Learn the explanation model.
explainer = Ridge(alpha=1, fit_intercept=True, random_state=64)
_ = explainer.fit(local_samples_z[:,nonzero_coefs], local_samples_y, sample_weight=weights)

# Fitness.
# This can be a score to judge how good the local approximation is.
print(explainer.score(local_samples_z[:,nonzero_coefs], local_samples_y, sample_weight=weights))

exp = pd.DataFrame({
  "tok": np.array(sorted_vocab)[present_tok_id[nonzero_coefs]],
  "imp": explainer.coef_
})
print(exp.sort_values("imp", ascending=False))
```

We try a smaller local sample size in our exercise,
but we can already successfully calculate very closely the feature contribution scores as in `lime`'s API.

#### Explain Neural Networks {-}

Now let's try a shallow neural network model with word embeddings trained from scratch.
We use `tensorflow.keras` API to quickly build and train a neural net.
We average word embeddings as the document embeddings for each review,
then feed-forward a ReLU layer before the sigmoid activation for cross-entropy optimization.

As an exercise,
instead of re-using the vocabulary built by `TfidfVectorizer` with `scikit-learn`,
we will re-tokenize the text data with `keras.preprocessing` module.
The inherent consistency under the Keras framework will also simplify our latter works on network layering.

```{python imdb_nn}
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences

# Build vocabulary. We use similar size as in our previous TfidfVectorizer.
# Since we will use zero padding, 0 cannot be used as OOV index.
# Keras tokenizer by default reserves 0 already. OOV token, if used, will be indexed at 1.
# Note that len(tokenizer.index_word) will be all vocabulary instead of `num_words`.
vocab_size = 20001  # +1 for 0 index used for padding.
oov_token = "<unk>"
tokenizer = Tokenizer(lower=True, oov_token=oov_token, num_words=vocab_size)
tokenizer.fit_on_texts(imdb_reviews_train)

# Encode text with padding to ensure fixed-length input.
seq_train = tokenizer.texts_to_sequences(imdb_reviews_train)
seq_train_padded = pad_sequences(seq_train, padding="post")
maxlen = seq_train_padded.shape[1]
seq_test = tokenizer.texts_to_sequences(imdb_reviews_test)
seq_test_padded = pad_sequences(seq_test, padding="post", maxlen=maxlen)

assert tokenizer.index_word[1] == oov_token
assert seq_train_padded.max() == vocab_size - 1

# Wrap Keras Sequential model with scikit-learn API.
# This is because LimeTextExplainer seems buggy with a native Keras model.
nn_model_file = os.path.join(model_dir, "text_clf_nn.h5")

def nn_model_fn():
  embedding_size = 64
  model = tf.keras.Sequential([
    tf.keras.layers.Embedding(
      vocab_size, embedding_size, input_length=maxlen,
      mask_zero=True, name="word_embedding"),
    tf.keras.layers.GlobalAveragePooling1D(name="doc_embedding"),
    tf.keras.layers.Dense(embedding_size / 2, activation="relu", name="relu"),
    tf.keras.layers.Dense(1, activation="sigmoid", name="sigmoid")
  ], name="nn_classifier")
  model.compile(optimizer="adam",
                loss="binary_crossentropy",
                metrics=["accuracy"])
  return model

print(nn_model_fn().summary(line_length=90))

imdb_nn = tf.keras.wrappers.scikit_learn.KerasClassifier(nn_model_fn)
if not os.path.exists(nn_model_file):
  metrics = imdb_nn.fit(
    x=seq_train_padded, y=imdb_y_train,
    batch_size=256, epochs=10,
    validation_data=(seq_test_padded, imdb_y_test),
    validation_steps=20,
    callbacks=[
      tf.keras.callbacks.EarlyStopping(monitor="val_loss", patience=2),
      tf.keras.callbacks.ModelCheckpoint(nn_model_file, monitor="val_loss", save_best_only=True)
    ],
    verbose=2)

# Restore the model with wrapper.
imdb_nn.model = tf.keras.models.load_model(nn_model_file)
imdb_nn.classes_ = np.array([0, 1])
imdb_nn_yhat = imdb_nn.predict_proba(seq_test_padded)[:,1]
imdb_nn_pred = (imdb_nn_yhat > .5).astype(int)

print(classification_report(imdb_y_test, imdb_nn_pred))
print(roc_auc_score(imdb_y_test, imdb_nn_yhat))
```

Based on the testing AUC score,
our shallow neural network model did outperform a random forest.
Let's see how the explanation model tell us about the behavior of the neural network model.

```{python lime_imdb_nn}
def nn_predict_fn(text):
  # This is for sklearn wrapper only.
  seq = tokenizer.texts_to_sequences(text)
  seq = pad_sequences(seq, padding="post", maxlen=maxlen)
  return imdb_nn.predict_proba(seq)

imdb_nn_explainer = LimeTextExplainer(class_names=["Negative", "Positive"])

# Explain the same examples as in RF.
imdb_nn_tp_exp = imdb_nn_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_tp_idx[0]], nn_predict_fn, num_features=6)
imdb_nn_fp_exp = imdb_nn_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_fp_idx[0]], nn_predict_fn, num_features=6)

imdb_nn_tp_exp.save_to_file("/tmp/explain_text_nn_tp.html")
imdb_nn_fp_exp.save_to_file("/tmp/explain_text_nn_fp.html")
```

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_nn_tp.html"))
```

<br>

The above is the LIME explanation of the same positive example previously explained with a RF model.
We realize that,
though both models eventually give a positive prediction,
the neural network model has a very different opinion on how the positive prediction is formulated.
Instead of being confused and indecisive,
the NN model is actually over-confident about this prediction!
Some neutral words have disproportionate contribition to the positive,
pointing out the potential direction to improve the model.
For example,
can a bigram tokenizer be better?

How about the second example (which is a negative review)?
Our NN model also makes a mistake on this negative review,
by predicting it as a positive one.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_nn_fp.html"))
```

<br>

What's different here is the reaction to the negative word `bore`,
which is not seen in RF.

Without a explanation model,
it won't be easy for us to compare two models at this level of details.

#### Explain Transfer Learning {-}

One step further,
let's use pre-trained word embeddings for the neural nets and build another explanation model.
We will use [GloVe](https://nlp.stanford.edu/projects/glove/) (@pennington2014glove).
We use just the smaller GloVe model since our dataset is quite small.

```{python maybe_download_glove, results="hide"}
# Download GloVe pre-trained embeddings.
# The file is about 800MB so may take some time.
glove6b_remote_path = "http://nlp.stanford.edu/data/glove.6B.zip"
glove6b_local_path = os.path.join(cache_dir, "datasets", "glove.6B.50d.txt")
glove6b_fname = os.path.basename(glove6b_remote_path)
if not os.path.exists(glove6b_local_path):
  _ = tf.keras.utils.get_file(fname=glove6b_fname, origin=glove6b_remote_path,
                              extract=True, cache_dir=cache_dir)

glove_all = pd.read_csv(glove6b_local_path, sep=" ", header=None, index_col=0, quoting=3)
```

In building the GloVe embeddings we need to take special care about out-of-vocabulary token AND padding index since we will be using the Keras API.

```{python imdb_transfer_learning_vocab}
# Map vocabulary to pre-trained embeddings.
matched_toks = []
for i, w in tokenizer.index_word.items():
  if i < vocab_size:
    if w in glove_all.index:
      matched_toks.append(w)
    else:
      matched_toks.append(oov_token)

# Note that GloVe pre-trained embeddings does not include its own OOV token.
# We will use a global average embedding to represent OOV token.
print(len([t for t in matched_toks if t == oov_token]))  # How many OOVs?

glove_all.loc[oov_token] = glove_all.values.mean(axis=0)
glove = glove_all.loc[matched_toks].values

# Append dummy 0-index vector to support padding.
glove = np.vstack([np.zeros((1, glove.shape[1])), glove])
print(glove.shape)
```

Now let's build the neural network.
Most of the code will be the same as before,
only the `Embedding` layer now we will use a constant matrix for initialization.
We make the GloVe embeddings *trainable* so it will further adapt to our specific dataset.

```{python imdb_transfer_learning}
tr_model_file = os.path.join(model_dir, "text_clf_tr.h5")

def tr_model_fn():
  embedding_size = glove.shape[1]
  model = tf.keras.Sequential([
    tf.keras.layers.Embedding(
      vocab_size, embedding_size, input_length=maxlen,
      embeddings_initializer=tf.keras.initializers.Constant(glove),
      trainable=True, mask_zero=True, name="glove_embedding"),
    tf.keras.layers.GlobalAveragePooling1D(name="doc_embedding"),
    tf.keras.layers.Dense(embedding_size / 2, activation="relu", name="relu"),
    tf.keras.layers.Dense(1, activation="sigmoid", name="sigmoid")
  ], name="tr_classifier")
  model.compile(optimizer="adam",
                loss="binary_crossentropy",
                metrics=["accuracy"])
  return model

print(tr_model_fn().summary(line_length=90))

imdb_tr = tf.keras.wrappers.scikit_learn.KerasClassifier(tr_model_fn)
if not os.path.exists(tr_model_file):
  imdb_tr = tf.keras.wrappers.scikit_learn.KerasClassifier(tr_model_fn)
  metrics = imdb_tr.fit(
    x=seq_train_padded, y=imdb_y_train,
    batch_size=256, epochs=20,
    validation_data=(seq_test_padded, imdb_y_test),
    validation_steps=20,
    callbacks=[
      tf.keras.callbacks.EarlyStopping(monitor="val_loss", patience=2),
      tf.keras.callbacks.ModelCheckpoint(tr_model_file, monitor="val_loss", save_best_only=True)
    ],
    verbose=2)

# Restore the model with wrapper.
imdb_tr.model = tf.keras.models.load_model(tr_model_file)
imdb_tr.classes_ = np.array([0, 1])
imdb_tr_yhat = imdb_tr.predict_proba(seq_test_padded)[:,1]
imdb_tr_pred = (imdb_tr_yhat > .5).astype(int)

print(classification_report(imdb_y_test, imdb_tr_pred))
print(roc_auc_score(imdb_y_test, imdb_tr_yhat))
```

Our NN model with transfer learning has similar AUC score to the vanilla NN.
Let's use explanation modeling to see if there is any actual difference.

```{python lime_imdb_transfer_learning}
def tr_predict_fn(text):
  # This is for sklearn wrapper only.
  seq = tokenizer.texts_to_sequences(text)
  seq = pad_sequences(seq, padding="post", maxlen=maxlen)
  return imdb_tr.predict_proba(seq)

imdb_tr_explainer = LimeTextExplainer(class_names=["Negative", "Positive"])

# Explain the same examples as in RF.
imdb_tr_tp_exp = imdb_tr_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_tp_idx[0]], tr_predict_fn, num_features=6)
imdb_tr_fp_exp = imdb_tr_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_fp_idx[0]], tr_predict_fn, num_features=6)

imdb_tr_tp_exp.save_to_file("/tmp/explain_text_tr_tp.html")
imdb_tr_fp_exp.save_to_file("/tmp/explain_text_tr_fp.html")
```

For the same positive review,
again the model shows over-confidence.
Even the donimant words are the same.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_tr_tp.html"))
```

<br>

For the negative review,
interestingly,
the transfer learning NN indeed makes a correct prediction of negative label.
The word `bore` becomes the main driving force to lower down the score.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_tr_fp.html"))
```

<br>

#### Explain Recurrent Neural Nets {-}

As a final exercise on text classification,
let's experiment the explanation modeling with a recurrent neural network (RNN)
RNN is known to be able to capture sequential dependencies better than ngram bag-of-words approach.
^[Note that, even for a single recurrent layer, training a RNN will be prohibitively slow without a GPU.]

```{python imdb_rnn}
rnn_model_file = os.path.join(model_dir, "text_clf_rnn.h5")

def rnn_model_fn():
  embedding_size = glove.shape[1]
  model = tf.keras.Sequential([
    tf.keras.layers.Embedding(
      vocab_size, embedding_size, input_length=maxlen,
      embeddings_initializer=tf.keras.initializers.Constant(glove),
      trainable=True, mask_zero=True, name="glove_embedding"),
    tf.keras.layers.GRU(64, dropout=.2, name="GRU"),
    tf.keras.layers.Dense(1, activation="sigmoid", name="sigmoid")
  ], name="rnn_classifier")
  model.compile(optimizer="adam",
                loss="binary_crossentropy",
                metrics=["accuracy"])
  return model

print(rnn_model_fn().summary(line_length=90))

imdb_rnn = tf.keras.wrappers.scikit_learn.KerasClassifier(rnn_model_fn)
if not os.path.exists(rnn_model_file):
  metrics = imdb_rnn.fit(
    x=seq_train_padded, y=imdb_y_train,
    batch_size=32, epochs=10,
    validation_data=(seq_test_padded, imdb_y_test),
    validation_steps=20,
    callbacks=[
      tf.keras.callbacks.EarlyStopping(monitor="val_loss", patience=2),
      tf.keras.callbacks.ModelCheckpoint(rnn_model_file, monitor="val_loss", save_best_only=True)
    ],
    verbose=2)

# Restore the model with wrapper.
imdb_rnn.model = tf.keras.models.load_model(rnn_model_file)
imdb_rnn.classes_ = np.array([0, 1])
imdb_rnn_yhat = imdb_rnn.predict_proba(seq_test_padded)[:,1]  # Interence of RNN take time.
imdb_rnn_pred = (imdb_rnn_yhat > .5).astype(int)

print(classification_report(imdb_y_test, imdb_rnn_pred))
print(roc_auc_score(imdb_y_test, imdb_rnn_yhat))
```

RNN with pre-trained GloVe embeddings seems to work very well,
even for such a small dataset.
That's see how the explanation can differ, again, for the same two examples:

```{python lime_imdb_rnn}
def rnn_predict_fn(text):
  # This is for sklearn wrapper only.
  seq = tokenizer.texts_to_sequences(text)
  seq = pad_sequences(seq, padding="post", maxlen=maxlen)
  return imdb_rnn.predict_proba(seq)

imdb_rnn_explainer = LimeTextExplainer(class_names=["Negative", "Positive"])

# Explain the same examples as in RF.
imdb_rnn_tp_exp = imdb_rnn_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_tp_idx[0]], rnn_predict_fn, num_features=6)
imdb_rnn_fp_exp = imdb_rnn_explainer.explain_instance(
  imdb_reviews_test[imdb_rf_fp_idx[0]], rnn_predict_fn, num_features=6)

imdb_rnn_tp_exp.save_to_file("/tmp/explain_text_rnn_tp.html")
imdb_rnn_fp_exp.save_to_file("/tmp/explain_text_rnn_fp.html")
```

The same over-confidence for all NN models on this particular positive review.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_rnn_tp.html"))
```

<br>

For the negative review,
RNN also correctly predict the label.
This may relate to they both using the pre-trained embeddings.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_text_rnn_fp.html"))
```

<br>

### On Tabular Data Classifiers

Lots of data can be represented in tabular format.
Here we will use [UCI Heart Disease dataset](https://archive.ics.uci.edu/ml/datasets/Heart+Disease) for demo.
Particularly,
we use the Cleveland dataset which is commonly used in machine learning research.
^[V.A. Medical Center, Long Beach and Cleveland Clinic Foundation:Robert Detrano, M.D., Ph.D.]

```{python maybe_download_ucihd, results="hide"}
ucihd_remote_path = "https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data"
ucihd_fname = os.path.basename(ucihd_remote_path)
ucihd_local_path = os.path.join(cache_dir, "datasets", ucihd_fname)

if not os.path.exists(ucihd_local_path):
  _ = tf.keras.utils.get_file(fname=ucihd_fname, origin=ucihd_remote_path,
                              extract=False, cache_dir=cache_dir)
```

The dataset contains both numerical and categorical features
(all encoded in numerics already, please refer to the in-line comments for documentation).
It is tiny in both number of features and number of examples.
But as a demo case it should serve well the purpose.

```{python preprocess_ucihd}
ucihd_attr = [
  "age",
  "sex",      # 0 = female 1 = male
  "cp",       # chest pain type 1: typical angina 2: atypical angina 3: non-anginal pain 4: asymptomatic
  "trestbps", # resting blood pressure (in mm Hg on admission to the hospital)
  "chol",     # serum cholestoral in mg/dl
  "fbs",      # (fasting blood sugar > 120 mg/dl) (1 = true; 0 = false)
  "restecg",  # resting electrocardiographic results 0: normal 1: having ST-T wave abnormality 2: showing probable or definite left ventricular hypertrophy by Estes' criteria
  "thalach",  # maximum heart rate achieved
  "exang",    # exercise induced angina (1 = yes; 0 = no)
  "oldpeak",  # ST depression induced by exercise relative to rest
  "slope",    # the slope of the peak exercise ST segment
  "ca",       # number of major vessels (0-3) colored by flouroscopy
  "thal",     # 3 = normal; 6 = fixed defect; 7 = reversable defect
  "label"     # diagnosis of heart disease (angiographic disease status) 0: < 50% diameter narrowing 1-4: > 50% diameter narrowing
]
ucihd = pd.read_csv(ucihd_local_path, header=None, names=ucihd_attr, na_values="?")
categorical_attr = ["sex", "cp", "fbs", "restecg", "exang", "thal"]
for col in categorical_attr:
  ucihd[col] = ucihd[col].astype("category")

# Clean label.
ucihd.loc[ucihd["label"] > 1, "label"] = 1

print(ucihd.shape)
print(ucihd.groupby("label").size())  # Label distribution.
print(ucihd.head())
```

#### Explain Random Forest {-}

Again we try to explain tree ensembels.

```{python ucihd_rf}
# sklearn's implementation of RF doesn't allow missing value.
# For categorical (as string) we can leave one special category for missing,
# but for numerical we need to do some special encoding or imputation.
ucihd_2 = ucihd.copy()
ucihd_2.loc[ucihd_2["ca"].isna(), "ca"] = -1  # Encode missing numerical.

# One-hot encode all categorical features.
ucihd_2 = pd.get_dummies(ucihd_2, columns=categorical_attr, dummy_na=True)
ucihd_y = ucihd_2.pop("label")
ucihd_X_train, ucihd_X_test, ucihd_y_train, ucihd_y_test = train_test_split(
  ucihd_2, ucihd_y.values, test_size=.3, random_state=64)

ucihd_rf = RandomForestClassifier(n_estimators=100, random_state=64)
_ = ucihd_rf.fit(ucihd_X_train, ucihd_y_train)

ucihd_rf_yhat = ucihd_rf.predict_proba(ucihd_X_test)[:,1]
ucihd_rf_pred = ucihd_rf.predict(ucihd_X_test)

print(classification_report(ucihd_y_test, ucihd_rf_pred))
print(roc_auc_score(ucihd_y_test, ucihd_rf_yhat))
```

As one can see RF performs very well on this dataset.

To explain a model trained with numerical features,
`lime` by default will discretize continous variables into quantiles for ease of interpretation.
Discretization is done using statistics derived from the training dataset.

```{python lime_ucihd_rf}
from lime.lime_tabular import LimeTabularExplainer

cat_ind = [i for i, col in enumerate(ucihd_2.columns) if "_" in col]
ucihd_rf_explainer = LimeTabularExplainer(
  ucihd_X_train.values, class_names=["Negative", "Positive"],
  feature_names=ucihd_2.columns,
  categorical_features=cat_ind)

ucihd_rf_tp_idx = np.where(np.logical_and(ucihd_rf_pred == 1, ucihd_y_test == 1))[0]
ucihd_rf_fp_idx = np.where(np.logical_and(ucihd_rf_pred == 1, ucihd_y_test == 0))[0]

# We take one true positive and one false positive for examples.
ucihd_rf_tp_exp = ucihd_rf_explainer.explain_instance(
  ucihd_X_test.iloc[ucihd_rf_tp_idx[0]], ucihd_rf.predict_proba, num_features=4)
ucihd_rf_fp_exp = ucihd_rf_explainer.explain_instance(
  ucihd_X_test.iloc[ucihd_rf_fp_idx[0]], ucihd_rf.predict_proba, num_features=4)

ucihd_rf_tp_exp.save_to_file("/tmp/explain_tab_rf_tp.html")
ucihd_rf_fp_exp.save_to_file("/tmp/explain_tab_rf_fp.html")
```

Following the same idea in our discussion on text classifiers,
we choose two examples,
one true positive and the other false positive,
from the RF predictions to demonstrate explanation modeling.

##### A True Positive Prediction Explained {-}

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_tab_rf_tp.html"))
```

<br>

The explanation suggests several dominant features toward the positive.
For categoricals each category serves as individual contribution for explanation.
This is a natural consequence of one-hot encoding in our feature space.

##### A False Positive Prediction Explained {-}

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_tab_rf_fp.html"))
```

<br>

For the false positive case,
the model is less confident.
There are indeed more features driving negatively.
But one strong positive contribution from the feature `ca` (number of major vessels colored by flouroscopy) cancel out the entire negative driving forces.

#### Explain Gradient Boosting Trees {-}

Gradient boosting trees (GBT) is a powerful model family proven to work exceptionally well in many different applications.
Yet due to its ensembling nature,
GBT is also hard to intrepret in general.

Here we demo `lightgbm`'s implementation of GBT with LIME explanation.

```{python ucihd_lgb}
import lightgbm as lgb

ucihd_tr = lgb.Dataset(ucihd_X_train, label=ucihd_y_train)
ucihd_te = lgb.Dataset(ucihd_X_test, label=ucihd_y_test)

ucihd_lgb_params = {
  "learning_rate": .01,
  "boosting_type": "gbdt",
  "objective": "binary",
  "metric": ["binary_logloss", "auc"],
  "num_leaves": 8,
  "max_depth": 3,
  "min_data_per_leaf": 5,
  "verbose": -1,
  "seed": 64
}

ucihd_bst = lgb.train(
  params=ucihd_lgb_params,
  num_boost_round=300, early_stopping_rounds=20,
  train_set=ucihd_tr, valid_sets=[ucihd_te],
  verbose_eval=10)

ucihd_lgb_yhat = ucihd_bst.predict(ucihd_X_test)
ucihd_lgb_pred = (ucihd_lgb_yhat > .5).astype(int)

print(classification_report(ucihd_y_test, ucihd_lgb_pred))
print(roc_auc_score(ucihd_y_test, ucihd_lgb_yhat))
```

In this particular (rather small) dataset RF indeed outperforms GBT.
As a matter of fact,
based on [existing benchmark](https://github.com/interpretml/interpret/tree/master/benchmarks) a simple logistic regression may have a even higher score for this problem.
Nevertheless,
let's move on to our explanation model with LIME:

```{python lime_ucihd_lgb}
def ucihd_lgb_predict_fn(x):
  # We need to output 2 columns for binary prob prediction.
  p = ucihd_bst.predict(x).reshape(-1, 1)
  return np.hstack((1 - p, p))

ucihd_lgb_explainer = LimeTabularExplainer(
  ucihd_X_train.values, class_names=["Negative", "Positive"],
  feature_names=ucihd_2.columns,
  categorical_features=cat_ind)

# We take the same examples previously explained in our RF explanation model.
ucihd_lgb_tp_exp = ucihd_lgb_explainer.explain_instance(
  ucihd_X_test.iloc[ucihd_rf_tp_idx[0]], ucihd_lgb_predict_fn, num_features=4)
ucihd_lgb_fp_exp = ucihd_lgb_explainer.explain_instance(
  ucihd_X_test.iloc[ucihd_rf_fp_idx[0]], ucihd_lgb_predict_fn, num_features=4)

ucihd_lgb_tp_exp.save_to_file("/tmp/explain_tab_lgb_tp.html")
ucihd_lgb_fp_exp.save_to_file("/tmp/explain_tab_lgb_fp.html")
```

The behavior of GBT looks similar to that of RF in terms of these two examples.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_tab_lgb_tp.html"))
```

<br>

In both case,
the variable `ca` has a dominant impact on the final decision.
The two modesl also share the same confusion against the negative example.

```{r, echo=FALSE}
htmltools::includeHTML(parse_lime_html_output("/tmp/explain_tab_lgb_fp.html"))
```

<br>

##### Optimized Categorical Encoding in `lightgbm` {-}

**This section is a digression on `lightgbm` usage.**

Since `lime`'s API requires us to prepare our dataset in one-hot encoding representation,
our `lightgbm` code use the same data pipeline as in `scikit-learn` random forest.
But that is actually not optimized for `lightgbm`.
The following code chunk showcases the best practice of encoding categoricals in `lightgbm`:
We don't encode them at all!

```{python lgb_best_practice}
# We leave both missings and categoricals as-is in the dataset.
ucihd_train, ucihd_test = train_test_split(ucihd, test_size=.3, random_state=64)
ucihd_tr = lgb.Dataset(
  ucihd_train.drop("label", axis=1), label=ucihd_train["label"],
  categorical_feature=categorical_attr,
  free_raw_data=False)
ucihd_te = lgb.Dataset(
  ucihd_test.drop("label", axis=1), label=ucihd_test["label"],
  categorical_feature=categorical_attr,
  free_raw_data=False)

ucihd_bst_2 = lgb.train(
  params=ucihd_lgb_params,
  num_boost_round=300, early_stopping_rounds=20,
  train_set=ucihd_tr, valid_sets=[ucihd_te],
  verbose_eval=-1)

ucihd_lgb_yhat = ucihd_bst_2.predict(ucihd_test.drop("label", axis=1))
ucihd_lgb_pred = (ucihd_lgb_yhat > .5).astype(int)

print(roc_auc_score(ucihd_test["label"], ucihd_lgb_yhat))
```

To summarize,
There are two very special properties about `lightgbm` algorithm.
`lightgbm` treats missings natively as a special tree split point.
This allows us to keep the original missing as is and in many cases can result in better accuracy than imputation.^[`xgboost` is the first to introduce such missing treatment among all the GBT package. `lightgbm` follows.]

In addition,
`lightgbm` encodes categorical variables internally in a more efficient way.
So we don't even need to do one-hot encoding on our own.
Of course in this tiny dataset we won't see any noticable difference.
But for large applications the performance impact can be huge.
Whatever,
by skipping one-hot encoding pipeline our code can be much neater as well.

### On Image Classifiers

**TODO: Use a pre-trained model?**

# Shapley Value

Shapley value is a game theory term.
In a cooperative game with $n$ players (denoted as set $N$ with $\vert N\vert = n$),
Shapley value of a player is its contribution to the total payoff of the game,
after taking into account all possible coalition among players.

## A Cooperative Game

When each player in a cooperative game may contribute differently to the payoff,
Shapley value is a way to determine how important each player is to the final outcome.

We define a function $\nu(S)$ where $S$ is a set of $m$ players ($\vert S\vert = m$),
the value of $\nu$ is the expected payoff from all members in $S$ as a coalition.
Shapley value suggests that the contribution of an individual member $j$ is calculated as the following formula:

$$
\varphi_j(\nu) =
\sum _{S\subseteq N\setminus \{j\}}
\gamma(S, N)
\cdot
\bigg[ \nu(S_{j+}) - \nu(S_{j-}) \bigg],
$$

where

$$
\gamma(S, N) = \frac {m!(n - m - 1)!}{n!}
$$

is the permutation proportional weight,
and $N\setminus \{j\}$ is the entire player set except player $j$,
$S_{j+}$ denotes a coalition with player $j$,
$S_{j-}$ denotes a coalition without player $j$.

So essentially Shapley value of player $j$ is the *weighted average payoff difference* between all possible team work compositions (coalitions) with and without $j$.

## ML Models As Cooperative Games

@lipovetsky2001analysis postulate a machine learning model inference task as such a cooperative game.
Each feature value is now a player,
the payoff is the difference between the final predicted value and the average prediction value.
In this way,
Shapley value of a feature can well represent its importance in the contribution to the prediction.
Based on Shapely values of all features,
we are able to explain a blackbox prediction.
^[In their original work Shapley value is used to explain a large scale regression problem.
But the concpet can easily extend to any machine learning model not limited to a regression model.]

Now the real question is how can we implement the characteristic function $\nu(S)$ in order to calculate the payoff difference between any two feature coalitions?
There are many different implementations on this.
Here we briefly discuss some of them.

### Obtain $\nu(S)$ with Model Re-Training

$\nu$ in this case is exactly the model prediction function.
One obvious way of calculating the term $\nu(S_{j+}) - \nu(S_{j-})$ for a given feature coalition is hence to train two separate models,
one with only the coalition as feature sets ($S_{j-}$) and the other with the coalition plus the feature $j$ ($S_{j+}$).
Obviously this will be infeasible for large applications.

### Obtain $\nu(S)$ with Replacement Sampling

To bypass the need for re-training,
another way to obtain $\nu(S)$ is to marginalize the effect of all the features not present in the coalition set $S$.
This is done by predict the same target instance,
but with its non-coalition feature values replaced with random draws from the data.

This is better illustrated with an example.
Let's take the first row of the UCI Heart Disease data we explored just before:

```{python shapley_example}
print(ucihd.iloc[0])
```

To make the example neat,
assuming we are only looking at a model trained on the following four attributes:
`age`, `sex`, `cp`, `ca`.
Our goal now is to explain that model prediction given these 4 feature values.
We illustrate the idea using the following plot (assuming `age` is the feature to calculate Shapley value):

```{r shapley_coalition_viz, echo=FALSE}
g <- .01
d <- data.frame(
  x1=c(1, 2, 2, 3, 2, 3, 4, 2, 4, 2, 4, 2, 3, 2) + g,
  x2=c(2, 5, 3, 5, 3, 4, 5, 4, 5, 4, 5, 3, 5, 5) - g,
  y1=c(1, 7, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 2, 1) + g*2,
  y2=c(8, 8, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2) - g*2,
  r=c("Fixed (On)\n or\n Randomized (Off)",
      "Randomized",
      "Fixed", "Randomized",
      "Randomized", "Fixed", "Randomized",
      "Randomized", "Fixed",
      "Fixed", "Randomized",
      "Randomized", "Fixed",
      "Fixed")
)
ggplot(d) +
  geom_rect(mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2, fill=r), alpha=0.5) +
  geom_text(aes(x=x1+(x2-x1)/2, y=y1+(y2-y1)/2, label=r), size=4) +
  labs(x="Feature Value (Target Example)", y="Possible Coalitions") +
  theme(legend.position="none",
        axis.ticks.x=element_blank(),
        panel.background=element_blank()) +
  scale_x_continuous(
    position="top",
    breaks=1:4 + .5,
    labels=c("age=63", "sex=1", "cp=1", "ca=0"),
    expand=c(0, 0)) +
  scale_y_continuous(
    breaks=1:7 + .5,
    labels=7:1,
    expand=c(0, 0))
```

Each row in the plot represents a possible coalition case.
For example:
Row 1 indicates there is no coalition at all.
Row 7 indicates a coalition of the rest 3 features.
In each case,
features not included in the coalition are randomized by replacing them with a random draw from the dataset.
For each coalition case if we generate enough such (artificial) instances and average the result,
we marginalize their effects on the model,
as if they are not included in the model in the first place.
^[Such sampling scheme actually assumes independence among features,
which is in general not true.
More sophisticated sampling approach can be applied,
but that will be out of our scope in this notebook.]

For the target feature to calculate Shapley value,
we also use the same randomization technique to indicate whether it is in or out of the coalition.
Now $S_{j+}$ can be obtained by averaging model predictions over all randomized samples with feature `j` included in the coalition and all the other features replaced by random draws.
And similarly for $S_{j-}$ with only one tweak:
feature $j$ now is also randomized.
For each possible coalition (corresponding to each row in the plot) we need to do this marginalization computation.
After traverse through all possible coalitions,
we take the weighted average of all prediction differences to arrive at the estimated Shapley value,
with the weighting function $\gamma(S, N)$.

Even though this approach eliminates the need to re-train a pair of models for every coalition,
number of possible coalitions still grow exponentially with total number of features.
As a result,
in reality,
it is still not feasible for any large application.

### Obtain $\nu(S)$ with Monte Carlo

To further reduce the computing time,
another approach is to use Monte Carlo samples to approximate combinations of coalitions.
So essentially the task will be simplified to solve:

$$
\hat\varphi_j(\nu) =
\frac{1}{R} \sum _{r = 1}^R
\bigg[ \nu(S_{j+}^r) - \nu(S_{j-}^r) \bigg],
$$

where $R$ is number of Monte Carlo samples,
$S_{j+}^r$ is a feature set with a random number of features whose value being replaced with random draws from the data,
but fixing feature $j$.
$S_{j-}^r$ is almost the same except for also randomizing feature $j$.

This approximation makes Shapley value approach feasible now even for large applications.

## From Shapley to SHAP

In theory a Shapley value considers all possible feature interactions and is global for the underlying machine learning model.
This is very different from LIME where the explanation is only local to the original model.
Consequently Shapley explanations have better properties than LIME.
We can interpret individual prediction,
or we can calculate Shapley values for all examples and aggregate the effect to profile global feature importance.
Again the original model can be any blackbox algorithm.
All we need is the access to its prediction interface AND also the original training dataset in order to do the sampling approximation.

We will skip the hands-on exercise on Shapley value approach,
jumping directly to a more general and also computationally efficient approach: SHAP
But the discussion here will definitely help us understand SHAP since they are closely related to each other.

# SHAP

@NIPS2017_7062 propose SHAP (**SHapley Additive exPlanations**),
yet another additive feature attribution method for model explainability.
It is a more general approach where both LIME and Shapley value are indeed only a special case of it.
Of course SHAP is also model-agnostic,
in theory it can be applied to *any* machine learning model,
but `shap` comes with a customized fast implementation particularly for gradient boosting trees (GBT).
It supports APIs of well-known open source GBT libraries such as
[`xgboost`](https://github.com/dmlc/xgboost),
[`lightgbm`](https://github.com/microsoft/LightGBM),
and [`catboost`](https://github.com/catboost/catboost).

It assigns each feature an importance value for a particular prediction.
Hence it provides for any given model prediction what may be the driving force for the model to make such prediction.

`shap` also comes with more visualization methods for feature investigation,
especially for feature interaction exploration.

**TODO: Theory Briefing here.**

## Hands-on Explanation Demo

### On Text Classifiers

#### Explain Random Forest {-}

`shap.TreeExplainer` is optimized for GBT but not RF.
For model with high dimensionality like a bag-of-words model it will suffer from high computation cost for non-GBT model.
Hence we will skip the discussion on RF and move forward to a GBT implementation.

#### Explain Gradient Boosting Trees {-}

In the previous section we didn't train a GBT for the text classification problem.
So let's quickly build one such model first (with the same TF-IDF vectorization as we did for the RF model).

```{python imdb_lgb}
# lightgbm does not allow utf-8 encoded feature names.
# Since important tokens are most likely ascii-compatible for our dataset,
# we simply strip non-ascii as a workaround for this exercise.
def remove_non_ascii(s):
  return "".join([i if ord(i) < 128 else "_" for i in s])

sorted_vocab_ascii = [remove_non_ascii(v) for v in sorted_vocab]

imdb_X_tr = lgb.Dataset(imdb_X_train, label=imdb_y_train, feature_name=sorted_vocab_ascii)
imdb_X_te = lgb.Dataset(imdb_X_test, label=imdb_y_test, feature_name=sorted_vocab_ascii)

imdb_lgb_params = {
  "learning_rate": .05,
  "boosting_type": "gbdt",
  "objective": "binary",
  "metric": ["binary_logloss", "auc"],
  "num_leaves": 16,
  "max_depth": 4,
  "min_data_per_leaf": 20,
  "verbose": -1
}

imdb_lgb_model_file = os.path.join(model_dir, "text_clf_lgb.txt")

# Save/reload model to save notebook rendering time.
if os.path.exists(imdb_lgb_model_file):
  # Parameters are not loaded back? (Which cause the subsequent call to shap_values fail.)
  # https://github.com/microsoft/LightGBM/issues/2613
  # As a workaround we pass the same parameters to re-construct the model.
  imdb_bst = lgb.Booster(model_file=imdb_lgb_model_file, params=imdb_lgb_params)
else:
  imdb_bst = lgb.train(
    params=imdb_lgb_params,
    num_boost_round=1000, early_stopping_rounds=20,
    train_set=imdb_X_tr, valid_sets=[imdb_X_te],
    verbose_eval=100)
  _ = imdb_bst.save_model(imdb_lgb_model_file)

imdb_lgb_yhat = imdb_bst.predict(imdb_X_test)
imdb_lgb_pred = (imdb_lgb_yhat > .5).astype(int)

print(classification_report(imdb_y_test, imdb_lgb_pred))
print(roc_auc_score(imdb_y_test, imdb_lgb_yhat))
```

Based on the testing AUC score we find out that GBT performs comparably to neural network models.

Just like RF we will have access to the overall feature importance with a GBT model:
^[By default `lightgbm` calculates the importance by counting how many times a feature contributes to an optimal split during training.
It also supports the impurity-based approach with argument `importance_type` set to `"gain"`.]

```{python imdb_lgb_feat_imp}
ax = lgb.plot_importance(imdb_bst, max_num_features=20)
plt.show()
```

The global feature ranking reveals some highly ranked features to be meaningless on its own.
Especially the word `it`.
But as discussed earlier we shouldn't over-interpret the ranks without a proper explanation modeling.

Since `shap.TreeExplainer` is customized for GBT for speed,
we can feed in all testing examples to calculate all shap values at once.

```{python shap_imdb_lgb}
import shap

# Sparse matrix is supported by shap for lightgbm models.
imdb_lgb_explainer = shap.TreeExplainer(imdb_bst)
imdb_lgb_shap_values = imdb_lgb_explainer.shap_values(imdb_X_test)

def imdb_lgb_shap_plot(test_id, matplotlib=True):
  shap_plt = shap.force_plot(
    imdb_lgb_explainer.expected_value[1],
    imdb_lgb_shap_values[1][test_id,:],
    imdb_X_test[test_id,:].toarray(),  # We still need a dense matrix here.
    feature_names=sorted_vocab,
    matplotlib=matplotlib
  )
  return shap_plt
```

##### Global Importance {-}

One advantage of `shap` on GBT models is the capability of traverse through all the testing examples due to its efficiency.
So we can based on all the resulting shap values to derive a global feature importance judged by their average shap values (contributions).
Note that this is different from the loss/impurity or split time-based feature ranking derived from RF/GBT *during training*.
It is an aggregation from all local prediction explanations (contributions) *during testing data inference*.

```{python shap_imdb_lgb_feat_imp}
shap.summary_plot(imdb_lgb_shap_values, imdb_X_test, feature_names=sorted_vocab,
                  plot_type="bar", max_display=20, show=False, plot_size=.25)
plt.show()
```

As we can see,
the ranking based on shap values for testing set will be in general different from the ranking based on training split.
And it is more *interpretable*:
Features with higher rank literally have averagely higher impact on the testing dataset.
Also the ranking can be conditioned on labels.

##### Local Explanation {-}

The most important application of `shap` still lies on instance-level explanation.
We stick to the previous two reviews.
For the review that RF correctly label positive,
we have the `shap` explanation with the following visualization:

```{python shap_imdb_lgb_tp_exp}
imdb_lgb_shap_plot(imdb_rf_tp_idx[0])
```

Note that by default `shap` for `lightgbm` shows log-odds rather than probability in the plot.
So a positive value indicates a positive prediction,
otherwise negative.

To verify this:

```{python verify_log_odds}
def to_log_odds(p):
  return np.log(p / (1 - p))

def to_p(log_odds):
  return np.exp(log_odds)/(1 + np.exp(log_odds))

# Take the first true positive to examine:
p = imdb_bst.predict(imdb_X_test[imdb_rf_tp_idx[0],:].toarray())
print(p)
print(to_log_odds(p))  # This is the reported number on the default shap plot.
```

For any given prediction,
the shap values of all features should sum up to the difference between the predicted log-odds and the expected log-odds.
To verify this on the specific positive example:

```{python verify_shap_values}
expected_log_odds = imdb_lgb_explainer.expected_value[1]
predicted_log_odds = to_log_odds(p)

print(predicted_log_odds - expected_log_odds)  # The difference.

shap_v = pd.DataFrame({
  "token": sorted_vocab,
  "shap_value": imdb_lgb_shap_values[1][imdb_rf_tp_idx[0],:],
  "tfidf": np.squeeze(imdb_X_test[imdb_rf_tp_idx[0]].toarray())
})
shap_v = shap_v.sort_values("shap_value", ascending=False)
print(shap_v)  # Shap values of all features for the example.

print(shap_v.shap_value.sum())  # The sum of shap values.
```

From the entire shap values we can know for example that the absence of `great` contributes negatively,
and the presence of `love` contributes positively,
to the final prediction.

```{python shap_imdb_lgb_fp_exp}
imdb_lgb_shap_plot(imdb_rf_fp_idx[0])
```

For the false positive case,
similar to RF,
the word `great` play a big role in shaping the GBT prediction toward positive.

#### Explain Neural Nets with Word Embeddings {-}

As of `r format(Sys.time(), '%Y-%m-%d')` `shap.DeepExplainer` does not yet support TF 2.0.^[https://github.com/slundberg/shap/issues/850.]
And `shap.GradientExplainer` is not well documented yet for TF 2.0.
So we will use the `shap.KernelExplainer` which is a implementation-agnostic explainer in `shap`.
The compromise is that it will run very slow for each prediction.

```{python shap_kernel_imdb_nn}
imdb_exp_ind = np.array([imdb_rf_tp_idx[0], imdb_rf_fp_idx[0]])
# KernelExplainer.
def mm(X):
  return imdb_tr.predict_proba(X)[:,1]

imdb_nn_shap_explainer = shap.KernelExplainer(mm, seq_train_padded[:100])
# This is VERY slow...
#imdb_nn_kernel_shap_values = imdb_nn_shap_explainer.shap_values(seq_test_padded[imdb_exp_ind])
# TODO:
# Contribution is attributed to original sequence input.
# In order to make explanation readable,
# we need to map each position to original word id then to word.
```

```python
# TODO: Makje sure everything works here.

# shap does not support keras model in scikit-learn wrapper.
# Let's re-build the model and retain its Sequental class.
dl_model = model_fn()
metrics = dl_model.fit(
  x=seq_train_padded, y=imdb_y_train,
  batch_size=256, epochs=20,
  validation_data=(seq_test_padded, imdb_y_test),
  validation_steps=20,
  callbacks=[
    tf.keras.callbacks.EarlyStopping(monitor="val_loss", patience=2),
    tf.keras.callbacks.ModelCheckpoint(tr_model_file, monitor="val_loss", save_best_only=True)
  ],
  verbose=0)

# DeepExplainer.
dl_shap_explainer = shap.DeepExplainer(dl_model, seq_train_padded)  # Wont' work.

# GradientExplainer.
imdb_nn_shap_explainer = shap.GradientExplainer(dl_model, seq_train_padded[:100])

imdb_nn_shap_explainer = shap.GradientExplainer(
  (imdb_tr.layers[0].input, imdb_tr.layers[-1].output),  # Not working for TF 2.0.
  seq_train_padded[:100])
imdb_nn_shap_explainer.shap_values(seq_test_padded[:3])  # Error here.
```

### On Tabular Data Classifiers

We do the same exercise on the tabular dataset previously explained by `lime`.

#### Explain Random Forest {-}

```{python shap_ucihd_rf}
ucihd_rf_explainer = shap.TreeExplainer(ucihd_rf)
ucihd_rf_shap_values = ucihd_rf_explainer.shap_values(ucihd_X_test)

def ucihd_rf_shap_plot(test_id, matplotlib=True):
  shap_plt = shap.force_plot(
    ucihd_rf_explainer.expected_value[1],
    ucihd_rf_shap_values[1][test_id,:],
    ucihd_X_test.iloc[[test_id]],
    matplotlib=matplotlib
  )
  return shap_plt
```

##### Global Feature Importance {-}

From the global ranking we can confirm that variable `ca` is definitely an influential feature.

###### Shap value feature ranking {-}

```{python shap_ucihd_rf_feat_imp}
shap.summary_plot(ucihd_rf_shap_values, ucihd_X_test,
                  plot_type="bar", max_display=10, show=False, plot_size=.25)
plt.gcf().subplots_adjust(bottom=.25, left=.25)
plt.show()
```

###### Split-time-based feature ranking {-}

```{python ucihd_rf_feat_imp}
ucihd_rf_feat_imp = pd.Series(ucihd_rf.feature_importances_, index=ucihd_X_train.columns).sort_values()
ax = ucihd_rf_feat_imp.tail(10).plot(kind="barh")
plt.show()
```

###### Feature Interaction {-}

We can plot *partial dependency* based on shap values of two features over the entire testing dataset.
For example,
by knowing that `ca` is important,
we'd like to further know how `age` can impact the contribution of `ca` across different examples.

```{python shap_rf_dep_plot_age_ca}
shap.dependence_plot("age", ucihd_rf_shap_values[1], ucihd_X_test, interaction_index="ca", show=False)
plt.gcf().subplots_adjust(left=.25)
plt.show()
```

The result suggests two things:

1. The model will predict higher risk for older people
2. `ca` has less impact for yonger people

Both can be examined by domain-experts to see if the model is learning the correct pattern that we expected or at least that we can reason.

##### Local Explanation {-}

Note that for `scikit-learn` RF model by default `shap` reports probability instead of log-odds.
Such behavior difference results from the optimization customized for GBT model family.

```{python shap_ucihd_rf_tp_exp}
# The true positive case in RF.
ucihd_rf_shap_plot(ucihd_rf_tp_idx[0])
```

```{python shap_ucihd_rf_fp_exp}
# The false positive case in RF.
ucihd_rf_shap_plot(ucihd_rf_fp_idx[0])
```

#### Explain Gradient Boosting Trees {-}

For GBT we feed the model that is optimized,
where categoricals are encoded internally without explicit one-hot encoding.

```{python shap_ucihd_lgb}
ucihd_lgb_explainer = shap.TreeExplainer(ucihd_bst_2)
ucihd_lgb_shap_values = ucihd_lgb_explainer.shap_values(ucihd_test.drop("label", axis=1))

def ucihd_lgb_shap_plot(test_id, matplotlib=True):
  shap_plt = shap.force_plot(
    ucihd_lgb_explainer.expected_value[1],
    ucihd_lgb_shap_values[1][test_id,:],
    ucihd_test.iloc[[test_id]].drop("label", axis=1),
    matplotlib=matplotlib
  )
  return shap_plt
```

##### Global Feature Importance {-}

###### Split-time-based feature ranking {-}

```{python ucihd_lgb_feat_imp}
ax = lgb.plot_importance(ucihd_bst_2, max_num_features=10)
plt.show()
```

###### Shap value feature ranking {-}

```{python shap_ucihd_lgb_feat_imp}
shap.summary_plot(ucihd_lgb_shap_values, ucihd_test.drop("label", axis=1),
                  plot_type="bar", max_display=10, show=False, plot_size=.25)
plt.gcf().subplots_adjust(bottom=.25)
plt.show()
```

###### Feature Interaction {-}

```{python shap_lgb_dep_plot_age_ca}
shap.dependence_plot("age", ucihd_lgb_shap_values[1],
                     ucihd_test.drop("label", axis=1), interaction_index="ca", show=False)
plt.gcf().subplots_adjust(left=.25)
```

##### Local Explanation {-}

```{python shap_ucihd_lgb_tp_exp}
ucihd_lgb_shap_plot(ucihd_rf_tp_idx[0])
```

```{python shap_ucihd_lgb_fp_exp}
ucihd_lgb_shap_plot(ucihd_rf_fp_idx[0])
```

#### Impact of One-Hot Encoding On Explanation {-}

As one may now realize,
by explicitly one-hot-encode the categorical features we essentially split them into different features in their interpretable representation.
This can be either good or bad, depending on the actual use case.
From this particular aspect libary such as `lightgbm` provides the flexibility to allow us choose whether to do the one-hot encoding or not.
So the way we want to construct the explanation model may well affect our implementation of the original model.

### On Image Classifiers

**TODO: Use a pre-trained model?**

# Explainable Boosting Machine

@nori2019interpretml publish the open source package `interpret` for a fast implementation of **Generalized Additive Models with Pairwise Interactions, or GA<sup>2</sup>M** (@lou2013accurate).
As of `r format(Sys.time(), '%Y-%m-%d')`, `interpret` is still in its alpha release with limited documentation.
The library contains two groups of modeling frameworks:

+ `glassbox`: explanable machine learning models
+ `blackbox`: machine learning explanation models (such as LIME and SHAP)

We've already covered the mainstream approach in the second group,
i.e.,
models that approximate (locally) the original model (supposed to be a blackbox) for better explainability.
The more interesting part of `interpret` is to bring about another type of model that is readily interpretable from its very origin,
and yet still competitively accurate:
the **Explainable Boosting Machine**, or EBM.

EBM is an additive model of the form:

$$
g(E(y)) = \beta_0 + \sum f_j (x_j) + \sum f_{ij}(x_i, x_j),
$$

where $g(\cdot)$ is a link function (sigmoid for binary classification, for an example),
$f_j$ is the *feature function* for the $j$-th feature,
learned by a gradient boosting algorithm with only that feature at a time and in a round-robin fashion for all features.
$f_{ij}$ is a *pairwise interaction* feature function to further boost the accuracy of the model while remain interpretability.

The model is interpretable since the contribution of any individual feature can be directly quantified by their corresponding feature function $f_j$.
Such explanation can extend up to pairwise interaction if pairwise feature functions are also estimated.

## Feature Shape Functions

The individial feature functions are also referred to as *shape functions* in GAM literature.
The name probably comes after the fact that upon finishing learning the function,
we can plot its output value $f_j(x_j)$ against its input value $x_j$,
effectively visaulize the shape of possible contributions of that feature along its values over a dataset.

Note that although GAM is linear due to its additivity,
each individual shape function can be (and mostly is) non-linear.
@lou2012intelligible has done a comprehensive experiment on GAM (without variable interaction) over several datasets.
They found that *bagged trees* as shape functions and *gradient boosting* as GAM learner has the best accuracy over several other choices.

To briefly summarize the gradient boosting training loop,
here is the pseudo code:

```
set total iteration = M
set total feature = N
initialize all f_j with 0
for m in 1 to M:
  for j in 1 to N:
    calculate residuals with full GAM model
    learn f_j against residuals and update the full GAM model
```

## FAST Pairwise Interaction Detection

It will be infeasible to include all pairwise interaction since the number of possible pairs grows quadratically with total number of features.
GA<sup>2</sup>M proposes an efficient way to rank potentially significant interaction pairs to largely reduce number of feature functions to learn.
The pair ranking or detecting algorithm is called FAST in the original paper.

Given the current best model,
potential interactions are detected on model residual.
And the residual sum of squares (RSS) is used as the criteria whether to include additional interaction.
If RSS does not reduce enough,
it is suggesting the additional interaction is doing no benefit to the current best model.

In a bit more details,
FAST contains two stages:

1. [STAGE 1] Build the best GAM without interactions, i.e., $g(E(y)) = \beta_0 + \sum f_j (x_j)$
2. [STAGE 2] Fix $f_j$ for all $j$, iteratively build interaction functions $f_{ij}$ based on RSS reduction

In stage one the process of learning one-dimensional feature functions is also called *feature shaping*.
In stage two where we extend GAM to GA<sup>2</sup>M,
$f_{ij}$ is a bivariate tree model with efficient implementation based on cumulative histograms of the two involving features.
Additionally,
continuos features are further discretized into bins (say, 256 bins) of equi-frequency to speed up the tree split training.
^[This is referred to as *histogram tree* approach and is also adopted in LightGBM's implementation of gradient boosting trees.
Experiments suggest such approach greatly reduce training time without compromising model accuracy.]

## Global Feature Ranking

GA<sup>2</sup>M rank each feature importance (either one-dimensional or interaction) by the standard deviation of the function values: $\sqrt{E(f_j^2)}$
Note that in a reduced form where feature function itself is linear:
$f_j(x_j) = w_jx_j$,
according to the formula the weight directly corresponds to the importance value:
$\sqrt{E(f_j^2)} = w_j$.

In plain words,
the importance score measures how volatile the contribution of a given feature is over a given training set.
A feature with higher volatility essentially play a bigger role in shaping the final model decision.
Hence it is (globally) more important.

## Hands-on Explanation Demo

### On Text / Image Data

EBM is not efficient for text dataset.
Due to the algorithm's design it will run too long for bag-of-words model since there are too many feature functions to estimate.
If we fit a EBM with the movie review dataset (definitely not a big one),
we will encounter OOM (out-of-memory) issue even without interaction terms.
As a result,
we will skip the discussion of EBM on a text classifier.
(The same restriction applies to image dataset.)

### On Tabular Data

`ExplainableBoostingClassifier` has a `scikit-learn` fashion API and hence is straightforward to use.

```{python ucihd_ebm, results="hide"}
from interpret.glassbox import ExplainableBoostingClassifier

ucihd_ebm = ExplainableBoostingClassifier(
  n_estimators=16, feature_names=ucihd_2.columns, n_jobs=1)
_ = ucihd_ebm.fit(ucihd_X_train, ucihd_y_train)

ucihd_ebm_yhat = ucihd_ebm.predict_proba(ucihd_X_test)[:,1]
ucihd_ebm_pred = (ucihd_ebm_yhat > .5).astype(int)

print(classification_report(ucihd_y_test, ucihd_ebm_pred))
print(roc_auc_score(ucihd_y_test, ucihd_ebm_yhat))
```

The model performs very well on the heart disease dataset,
outperforming both RF and GBT.
^[To use FAST algorithm to detect interactions we need to pass explicitly an integer argument `interactions` to the constructor.
By default `interactions=0`, i.e., no interaction is actually estimated at all.
After several experiments it seems that in this particular case interactions does not help improve the model.
So we stick to the default setting.]

#### Global Explanation {-}

`interpret` comes with a rich set of visualization tools (with [`plotly`](https://plot.ly/) as its backend).
Model explanation is divided into two groups:
global and local.

For global explanation,
we have access to both global feature importance and a per-feature feature contribution stats.

```{python ucihd_ebm_global_explain}
ucihd_ebm_global = ucihd_ebm.explain_global()
# All feature info:
print(ucihd_ebm_global.selector)
```

```{python ucihd_ebm_global_explain_plot}
# Global feature importance.
ucihd_ebm_global.visualize().write_html("/tmp/ucihd_ebm_feat_imp.html", include_plotlyjs=False)

# Global contribution on age.
fid = ucihd_ebm_global.selector.Name.tolist().index("age")
ucihd_ebm_global.visualize(fid).write_html("/tmp/ucihd_ebm_age_imp.html", include_plotlyjs=False)

# Global contribution on trestbps.
fid = ucihd_ebm_global.selector.Name.tolist().index("trestbps")
ucihd_ebm_global.visualize(fid).write_html("/tmp/ucihd_ebm_trestbps_imp.html", include_plotlyjs=False)

# Global contribution on sex.
fid = ucihd_ebm_global.selector.Name.tolist().index("sex_0.0")
ucihd_ebm_global.visualize(fid).write_html("/tmp/ucihd_ebm_sex_imp.html", include_plotlyjs=False)
```

##### Global Feature Importance {-}

As we discussed earlier the global feature importance score is represented by the standard deviation of the feature function output.
Features marked more important means that they are more "active" in shaping the model decision.
^[Feature shaping plot for interaction will be plotted as a heatmap.
We dind't demo that since interaction didn't help our model at all.]

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_feat_imp.html")
```

##### Feature Shaping: Age {-}

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_age_imp.html")
```

##### Feature Shaping: Resting Blood Pressure {-}

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_trestbps_imp.html")
```

##### Feature Shaping: Gender (Female) {-}

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_sex_imp.html")
```

#### Local Explanation {-}

More importantly,
we must be able to explain a specific model prediction locally.
EBM is inherently able to do exactly that.
Using `interpret` this can be done easily with a couple of lines:

```{python ucihd_ebm_local_explain}
# Explain the same instances previously on RF.
ucihd_exp_ind = np.array([ucihd_rf_tp_idx[0], ucihd_rf_fp_idx[0]])

# We can feed multiple examples at the same time.
ucihd_ebm_local = ucihd_ebm.explain_local(
  ucihd_X_test.iloc[ucihd_exp_ind,:], ucihd_y_test[ucihd_exp_ind])
ucihd_ebm_local.visualize(0).write_html("/tmp/ucihd_ebm_exp_tp.html", include_plotlyjs=False)
ucihd_ebm_local.visualize(1).write_html("/tmp/ucihd_ebm_exp_fp.html", include_plotlyjs=False)
```

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_exp_tp.html")
```

For the false positive case made by both RF and GBT,
EBM is able to correctly predict the negative label.
We still see a positive `ca` value contribute a lot toward a positive prediction,
while EBM is able to also pick up several negative factors that jointly negate the positive impact,
ending up with a correct prediction toward negative.

```{r, echo=FALSE}
htmltools::includeHTML("/tmp/ucihd_ebm_exp_fp.html")
```

# From Explanation to Trust

Throughout all the exercises above we only demonstrate limited local actual examples,
so nothing really conclusive here as which model is more reasonable for each problem in making their decision.
But with more investigation there may be more insights on which model can be trusted more than the others.

We summarize the benefit of explanation modeling here.
In general it allows us...

1. To reason the model behavior at a single instance level
2. To investigate unreasonable behavior such that we can further improve the original model with feature engineering
3. To differentiate different models with similar testing scores
4. To build trust on a model, especially for the end user, to better formulate the subsequent action item

# References
